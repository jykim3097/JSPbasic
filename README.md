# jsp-basics
study jsp

### 210420

## JDBC : Java DataBasce Connected 
### 새로운 시작! 언어와 DB의 연결
* 필요한 데이터를 DB에서 JAVA로 가져오고
* 저장할 데이터를 JAVA에서 DB로 가져오고
* 고전 방법, 근본이 된다
* 속도상으로 빨라서 여전히 사용하고 있다

### JDBC 프로그래밍
* JAVA API, 언어와 DB를 연결해주는 연결자
* 인터페이스로 작성되어있다
* ojdbc.jar : JDBC 드라이버
	* 이클립스에 jar 파일 연결하는 방법
	* 프로젝트에 lib 폴더를 만들고 jar 파일을 복사해서 이클립스에 연결한다
	* JDBC 프로젝트 안에서 jar 파일을 참조 라이브러리로 쓰도록 등록한다
* 이를 통해 java에서 DB에 insert, select, update를 할 수 있다

#### 상세
##### Oracle 드라이버 로딩
```(java)
Class.forName("oracle.jdbc.driver.OracleDriver");
```
##### 필요한 객체
1. 연결 객체 Connection : DB랑 JAVA 연결
```
String url = "jdbc:oracle:thin:IP주소:PORT번호/DB이름"; //18C 버전
String uid = "DB접속ID";
String upw = "DB접속PW";
Connection conn = DriverManager.getConnection(url, uid, upw);
```
2. statement 객체 : SQL  전송/수신 객체
```
String sql = "실행할 sql문";
PreparedStatement pstmt = conn.prepareStatement(sql);
```
* sql문에 '?'를 사용해 입력받은 값으로 수행할 수도 있다.
	* 물음표 갯수에 따라 순서대로 1부터 인덱스가 부여된다
	* 아래와 같이 사용
```
pstmt.setInt(1, id)
```
* select일 때만 executeQuery를 사용하고
* 나머지에서는 executeUpdate를 사용한다 > 0,1 반환 > 성공 시 1
3. ResultSet 객체 : SQL문 조회 결과를 '전부' 받아옴
	* Select 문에서만 필요하다!
	* rs.next()를 통해 다음 행에 접근할 수 있다
```
ResultSet rs = pstmt.executeQuery();
```

#### 클래스로 빼는 방법
* java 파일로 하나씩 만들 수도 있지만 클래스에 메서드를 만들어 사용하면 더 간편하다
* 클래스에 (멤버) 정보를 저장하고 클래스 단위로 사용할 수 있다

#### 인터페이스로 사용하는 방법
* 추상메서드로 선언하고 DAO 클래스에서 오버로딩한다

### 210421

#### JSP Start!
* JSP : Java Server Program
* 잘해두면 뒤에가 아주 편안할 것!

## 웹 프로그래밍이란?
* 인터넷 서비스, 웹을 기반으로 작동되는 프로그램
* 컴퓨터와 컴퓨터는 네트워크로 연결되어 있다
* java만 알고 있으면 할 수 있다
* JAVA를 사용하는 이유?
	* API가 풍부하다
	* 보안 장점이 있다

## 용어
### url
* http://192.110.32.11:8080/ + 경로
	* http + :// + ip주소 + : + 포트번호 + / + 경로
* 주소, 모든 정보가 혼합된 주소
* 고유하다 = 중복이 없다
#### 프로토콜
* url의 제일 처음에는 프로토콜이 나온다
* 네트워크 상에서 약속한 통신규약
	* **HTTP** : Hyper Text Transfer Protocol
		* HTTPS : Security, 보안강화문서, 신청하면 받을 수 있다
	* FTP : File Transfer Protocol
	* SMTP, POP : 메일 송수신
	* DHCP : 랜덤하게 IP 주소가 부여되는 규약
#### IP주소 : 특정 컴퓨터를 식별할 수 있는 주소
#### 포트번호 : 고유한 프로그램 번호
	* ex) oracle의 db 포트번호는 1521
#### 도메인 : ip주소를 사람이 외우기 쉽게 외우도록 mapping한 문자열

### HTTP 요청과 응답, 서버
* HTTP : HTML 문서를 전송하는 프로토콜
* 브라우저를 통해 인터넷 자원을 사용할 때 대부분 HTTP 프로토콜을 사용한다
* 서버 : 외부로부터 사용자의 접근을 가능하게 하는 컴퓨터
* 인터넷(접속 환경)에서 URL을 치고 만든 서버로 접속
* 서버는 프로그램을 가동해서 다시 인터넷으로 전달해준다
* 접속 환경 = 클라이언트 = 웹 브라우저
#### 클라이언트(웹브라우저)는 서버로 **요청(Request)**
#### 서버는 클라이언트(웹브라우저)로 **응답(Response)**
* 이 과정이 1초만에 일어난다
* 모든 프로그램은 다 이렇게 돌아간다
* 브라우저가 응답페이지를 해석해서 화면에 보여준다
	* 해석 = 렌더링
	* 렌더링 방식도 여러가지가 있다
* **웹 브라우저**와 **서버**의 동작 > 정적 데이터
* **웹 브라우저**에서 **서버**로 요청하고, 서버는 **DB**의 값을 조작해 동작 > 동적 데이터

## JSP
* HTML 페이지를 만들기 위한 방법 중 하나
* 컴파일 과정을 거치지 않고 서버에서 실행시킬 수 있다
* 웹서버에 의해 서블릿으로 변환된 다음 실행된다
	* 서블릿? 서버에서 실행되는 자바 프로그램
	* 사용자 > 서블릿 요청 > 서버 > 웹 서버 > 서블릿 객체 생성 > 사용자 요청 처리

### 톰캣
* 웹서버의 역할을 도와줌
* WAS : Web Application Server

### jsp 시작
* Dynamic Web Project
* java resources 에는 java 파일이 들어간다
* WebContent : 화면을 구현하는 파일들이 들어간다
	* html을 작성할 수 있다

### HTML
* 정적인 웹페이지를 만드는 언어
#### form 태그
* 매우매우 중요!

### 210422

## HTML
### HTML form 관련 태그
* input 태그로 입력되는 값을 서버로 전송한다
* type = checkbox : 여러 개의 데이터를 전송할 때 사용
* type = radio : 여러 개의 데이터 값 중 한 개만 전송할 때 사용
* checkbox와 radio는 같은 그룹끼리 같은 name을 지정해서 사용해야한다
* email 태그는 메일 형식을 지원해서 나중에 유용하다
* type이 submit, reset, button인 경우 value로 이름을 지정해줄 수 있다

### block과 inline
* 태그 이름은 보통 기능을 나타내는데 구도를 잡는 용도의 태그도 있다.
* block : 눈에 보이지 않는 전체 공간을 영역으로 잡음
	* 자동 개행이 된다
	* header, section, footer, div, form, ul, li, table, tr, td 등
	####block 요소 안에는 block 요소와 inline 요소가 자식태그로 들어갈 수 있다
* inline : 태그 내용 자체만 영역으로 잡음
	* 줄바꿈이 안된다
	* span, img, a, i, b, strong, small 등
	* inline 요소 안에는 block이 들어갈 수 없다
	#### inline 요소는 inline만 자식태그로 가질 수 있다

## JSP
* Servlet : java 클래스
	* 데이터 처리를 담당
	* java를 이용해 문서를 작성하고 출력객체를 이용해 html 코드를 삽입한다
* JSP : 화면구현 파일
	* HTML에 특정 언어를 쓸 수 있는 것
	* HTML의 형식을 똑같이 갖고 있으며, JAVA 코드도 쓸 수 있다 > 동적이다
		* JSP 태그를 이용해야한다
	* 클라이언트의 요청에 동적으로 작동하고, 응답은 HTML을 이용한다
	* 웹서버와 통신 시에 자동으로 Servlet으로 변환된다
	* MVC 패턴에서 View로 이용된다

### JSP 태그 종류
* 스크립트릿 : <% %>  
	* 거의 모든 java 코드를 입력할 수 있다
	* System.out.println() 구문으로 쓰면 consol창에 출력되고
	* out.println()이라고 쓰면 화면에 출력된다
		* html에서는 \r\n이 개행이 아니고 <br>이 개행이기 때문에 인식이 안된다
	* **지역변수 선언**
	* 페이지 새로고침 할 때마다 계속 실행
* 표현식 : <%= %>
	* JSP 내에서 사용되는 변수 값, 메서드 호출 결과를 출력하기 위해 사용
	* 결과 값은 String이고, ';'를 사용할 수 없다
* 선언식 : <%! %>
	* **전역**의 의미로 사용
	* 화면에 사용할 **메서드나 멤버변수**를 선언할 때 사용
	* 처음 한 번만 실행
* 주석 ㅣ <%-- --%>
	* HTML 주석은 브라우저에 모두 노출되지만 JSP 주석은 브라우저에서 볼 수 없다
	* 자바에서 사용하는 주석도 혼용할 수 있다
	* JAVA 코드는 JSP 주석으로 처리해줘야한다, HTML 주석은 인식하지 못한다
* 지시자
	* PAGE : PAGE의 전체적인 속성 정보 
		* **contentType** : 규격화된 문서 타입 지정
	* **INCLUDE** : 다른 페이지를 해당 페이지로 가져올 때 사용
	* TABLIB : 외부 라이브러리 사용할 때 

### 210423

## JSP 아키텍쳐
* jsp 파일 실행 > 웹서버 > jsp 파일을 java코드로 변환 > 컴파일 > html로 응답
* SSR : Server Side Rendering
	* 서버에서 사용자에게 보여줄 페이지를 모두 구성해 사용자에게 페이지를 보여주는 방법
* C:\...\apache-tomcat-9.0.45\wtpwebapps 안에 지금까지 만든 jsp 파일이 있다
* C:\...\apache-tomcat-9.0.45\work\Catalina\localhost\JSPbasic\org\apache\jsp\...
	* 이 경로에 **요청**이 들어올 때마다(실행될 때마다) java 파일과 class 파일이 추가된다
	* 실행 후 브라우저로 **응답**을 보내준다
### 웹서버와 WAS(Web Application Server)
* WAS : 웹 브라우저 같은 클라이언트에게 요청을 받으면 웹 서버에서 처리해서 다시 웹브라우저에 응답
* 웹서버는 정적 데이터를 요청 받아 처리하고
* WAS는 **동적 데이터**(JSP, ASP, PHP 등)를 요청 받아 처리한다
* 둘을 나누는 이유
	* 시간 효율성 > 정적데이터를 WAS로 처리할 필요가 없다
	* 보안 > WAS에는 DB 서버에 대한 접속 정보가 있기 때문에 공개될 필요가 없다
	* 참고) https://goldsony.tistory.com/37

## Servlet
* 클라이언트의 요청에 동적으로 작동, 응답은 HTML을 이용
* DB 만들어서 데이터 처리할 때 이용
* **JAVA thread를 이용해서 동작**
	* 직접 thread를 구현하는 건 아님
		* thread ? 하나의 클래스 파일을 나눠서 동작시키는 것
* MVC 패턴에서 Controller로 이용됨
* servlet과 jsp는 매우 유사한데,
	* **java**에서 만들어내면 **servlet**
	* **html**을 이용해서 만들면 **jsp**

### 서블릿 구분 방법
* servlet은 여러 개 있을 수 있기 때문에 구분해줄 필요가 있다.
* url mapping은 두가지 방법이 있는데 jsp에선 편한 걸로 사용하면 된다
#### URL MAPPING
* 장점: 주소 길이를 줄여주고, 경로를 노출시키지 않아 보안 위험이 감소한다
1. 어노테이션 사용
* @WebServlet("문자열")
* 브라우저 상에서 특정 단어 요청과 연결
* 어노테이션이 없다면 그냥 java 파일과 똑같음
* 어노테이션을 붙여 구분한다
* 경로가 간단해지고 보안에 유리해진다
* __서블릿 이름은 고유해야한다__
* 경로 : JSPbasic/KKK 와 같이 큰 프로젝트 이름 아래 적어주면 끝

2. web.xml 설정 파일 수정
* 프로젝트>WebContent>WEB-INF 아래 있는 web.xml에서 수정
* web.xml은 프로젝트 전체 설정 파일이기 때문에 오타가 한개라도 있으면 안된다 > 프로젝트 실행이 안된다!
* servlet/servlet-name : 실제 경로를 줄여 사용할 변수명
* servlet/servlet-class : 실제 경로
* servlet-mapping/url-pattern : 어떤 형식으로 붙여줄 건지, 실제 url에 작성되는 코드
	* 포트넘버/프로젝트이름/url-pattern
* 어노테이션 방법처럼 사용할 수 없다
* Deployment Descriptor: JSPbasic > Generate Deployment Descriptor stub를 하면 
* web.xml 파일이 생긴다

## HttpRequest (요청)

### GET
* 서버에 데이터를 **요청**하는 용도
* 전송하는 데이터가 모두 url 주소에 실려서 감
* 주소에 모든 것(필요한 값, 정보 등)을 담아서 보냄 > 보안에 취약하다
##### 단순히 페이지 이동과 같은 간단한 처리에 사용한다
##### 게시판 글 조회, 검색 등 서버 정보를 가져올 필요성이 있을 때 사용
* 전송 크기는 브라우저 별로 다르다(브라우저 별로 크기가 정해져 있다)
* header에 데이터가 실린다
* form으로 만든 submit 버튼을 누르면 form 내 데이터가 전송된다 (전송될 주소는 action 속성)
* __form이 반드시 필요하진 않다__
* 한글 인코딩하는 방법
	* 톰캣 > server.xml > 내가 사용하고 있는 포트번호의 Connector 태그로 이동
	* <Connector **URIEncoding="UTF-8"** ... 추가

### POST
* 서버에 데이터를 **전송**하는 용도
* 넘기는 값을 숨겨서 보내는 방식 > 보안에 강하다
* 보내는 문서의 body에 실어서 보낸다 > 외부에 노출되지 않는다
* **반드시 form이 필요하다**
* 실행은 됐지만 보이는 건 없다
* 중요한 값을 보낼 때 사용
	* 비밀번호나 주민번호와 같이 private한 데이터를 서버에 전송해야할 때 사용
* 데이터 크기에 제한 없이 전송할 수 있다(대량 전송 가능)
* 한글 처리 : 값을 꺼내기 직전에 처리
	* jsp 파일에 request.setCharacterEncoding("UTF-8");를 추가한다

## JSP 내장 객체
* 자동으로 생성되는 객체,  객체를 생성하지 않아도 사용할 수 있다
* JSP 컨테이너에 의해 서블릿으로 변환될 때 자동 생성
* 종류
	* request, response, out, session, application, pageContext, page, config, exception
	* Request와 Response가 가장 중요하다!

### Request 객체
* request : 웹 브라우저를 통해 서버에 어떤 정보를 요청하는 것
* 이러한 요청 정보가 담기고 관리되는 곳이 request 객체
* jsp에서 자동 생성되기 때문에 선언하지 않고 사용할 수 있다
* 브라우저에 대한 정보나 사용자가 전달하는 값 등 많은 정보를 저장하는 바구니 역할

#### 제공 기능
* 클라이언트(웹브라우저)와 관련된 정보 읽기 기능
* 서버와 관련된 정보 읽기 기능
* 클라이언트가 전송한 요청 파라미터 읽기 기능
* 클라이언트가 전송한 쿠키 읽기 기능

#### 주요 메서드
* **getContextPath() : 서버가 프로젝트를 식별할 수 있는 주소**
	* 웹 어플리케이션의 __컨텍스트 루트__(WAS에서 웹 어플리케이션을 구분하기 위한 path, 프로젝트명)의 경로를 얻는다
* getParameter(_name) : html 속성 중 name이 _name인 파라미터 값을 구한다. 존재하지 않으면 null 반환
* getParameterValues(_name) : html 속성 중 name이 _name인 모든 파라미터의 값을 배열로 구한다. 존재하지 않으면 null 반환
	* checkbox에서 쓰인다

#### URI & URL
* 참고) https://mygumi.tistory.com/139
* URI : 정보 리소스를 고유하게 식별하고 위치를 지정할 수 있다 
	* 포트번호를 제외한 폴더 경로
	* URI의 종류 두 가지 : URL, URN
* URL : URI의 가장 흔한 형태/전체 주소(경로)
	* 특정 서버의 한 리소스에 대한 구체적 위치를 서술
	* 리소스가 정확히 어디에 있고 어떻게 접근할 수 있는지 분명히 알려준다
* URN : 콘텐츠 리소스의 위치에 영향을 받지 않는 고유한 이름 역할

### Response 객체
* 브라우저가 요청한 정보를 담아 **서버에서 브라우저로** 보내주는 객체
* 웹 브라우저의 요청에 응답하는 것 = response
* 이러한 응답 정보를 갖고 있는 객체를 response객체라고 한다

### 210426

## 복습

### Get 방식
* 반드시 form 태그가 필요하지 않다
* 주소를 통해 강제로 파라미터 값을 전달할 수 있다

### POST 방식
* 보안에 유리하기 때문에 더 자주 사용한다
* form과 자주 사용한다

### Servlet
* 요청을 받아줄 수 있는 자바 클래스
* HttpServlet을 상속받는다

## OUT 내장 객체
* JSP가 생성하는 모든 내용이 OUT 객체를 통해 전송된다
* JSP 페이지 내에서 사용하는 비스크립트 요소들(HTML, TXT)이 OUT 객체에 전달된다
* 표현식 결과 값도 전달된다
* 그러나 대부분 표현식으로 대체된다

## css
* box-sizing: border-box; - div 길이에 맞춰진다
* required : 전송하려면 필수로 필요하다
* align 정렬 : 하위 요소에 전체 적용
* iFrame 태그 : 유투브에서 공유하기에서 코드를 그대로 가져올 수 있다


### 210427

## 내장객체
* 자동으로 생성되는 객체
* Request
* Response
* Out

## Cookie
* JSP의 내장 객체가 아니다
* Http 프로토콜은 응답 후 브라우저와의 관계를 종료하는데 → Connectionless Protocol
* 연결이 끊겼을 때, 어떤 정보를 지속적으로 유지하려고 쿠키라는 방식을 사용한다
* 인증값을 서버에서 생성해 브라우저(클라이언트, local)측에 저장, 관리한다
* 서버에서 요청할 때마다 쿠키의 속성값을 참조 또는 변경할 수 있다.
* 보안에 취약할 수 있다
* 어떤 쿠키가 있는지도 알 수 있다
* 용량에도 제한이 있다 (총 300개까지 저장 가능, 개당 4kb)
* 웹 서버 프로그램에는 다 있다
### 사용 방법(쿠키 문법)
1. 생성 : 서버에서 java 코드로 한다(개발자가 지정한다) (class Cookie)
2. 속성 설정 : 쿠키를 얼만큼의 기간만큼 유지할 건지 등의 상세한 속성 설정을 할 수 있다 (setter)
3. 저장 : 응답 객체에 담아 브라우저(local)로 보낸다 (브라워저에 저장하기 때문에 보내줘야한다) (response)
* 응답객체를 통해 서버에서 브라우저로 보내놓으면 request할 때 자동으로 서버로 보내진다
* 한 번 만들어놓으면 지정한 기간동안 자동으로 왔다갔다 한다
* 시간이 지나면 소멸된다
* {키 : 값}을 이루어져 있는 문자열 데이터
* JSESSIONID : 자동으로 생성돼서 넘어가는 값
* 같은 이름의 쿠키를 0초로 설정하면 삭제된다

## Session
* 내장 객체
* 서버와의 관계를 유지하기 위한 수단
* 서버 상에 객체 형태로 존재하고, 서버당 하나의 세션 객체를 가질 수 있다.
* 브라우저 별로 서로 다른 세션을 사용한다.
* 인증값이 서버에서 만들어져서 서버에서 저장, 관리한다
* 자바코드는 외부에서 볼 수 없기 때문에 매우 안전하다(보안이 좋다)
	* 쿠키와 개념은 아주 비슷한데 더 안전하다
* 데이터의 한계가 없다
* 서버가 관리하기 때문에 자동으로 30분 유지된다
* 클라이언트가 요청하면 자동 생성돼 고유 ID값을 클라이언트에 넘겨주고, 이것이 쿠키에 저장된다
* 서버가 관리하기 때문에 자동으로 30분 유지된다
* 세션은 30분이 지나거나 브라우저를 끄면 만료된다(소멸 조건)
* 세션에 저장하고 꺼내는 코드만 작성하면 된다
* 외워야할 메서드
	1. session.setAttribute() - 세션에 저장하는 메서드, 이름과 값을 저장한다
	2. session.getAttribute() - 세션에 저장되어 있는 데이터를 얻는다
	3. session.removeAttribute() - 특정 세션을 삭제한다
	4. session.invalidate() - 모든 세션을 삭제한다

## 쿠키 vs 세션
* 쿠키가 세션보다 보안에 취약하기 때문에 세션을 더 많이 쓴다
	* 쿠키는 네트워크를 통해 전달되기 때문에 HTTP를 사용하는 경우 중간에서 누군가 쿠키 값을 읽을 수 있다
	* 반대로 세션은 only 서버에만 저장되기 때문에 중요한 데이터를 저장하기 좋다
	* 세션은 항상 서버(톰캣)이 관리하고 있다
* 웹 브라우저가 쿠키를 지원하지 않거나 사용자가 쿠키를 차단한 경우에도 세션을 사용할 수 있다
* 세션은 한 서버에서 만들어지기 때문에 다른 서버와 공유가 안된다
* 쿠키는 여러 도메인에서 공유할 수 있기 때문에 서버간에 넘나드는 것이 가능하다
	* 홈페이지, 블로그, 카페 등등에서 동시에 같은 아이디를 사용할 수 있는 이유

## 그 외 필기
* js는 html 영역에 작성한다
* 단일값 > class > list
* session은 쓰레드로 동작한다. 브라우저마다 session이 생성되면 쓰레드를 많이 사용하게 되어 서버가 다운되기도 한다